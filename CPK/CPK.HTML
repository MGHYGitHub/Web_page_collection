<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¢å¼ºç‰ˆCPKè®¡ç®—å™¨ - å¸¦æ•°æ®æ¸…ç†</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1,
        h2,
        h3 {
            color: #333;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
        }

        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            border-color: #4CAF50;
            background-color: #f0fff0;
        }

        .upload-area p {
            margin: 0;
            font-size: 16px;
        }

        .upload-area i {
            font-size: 48px;
            color: #4CAF50;
            margin-bottom: 10px;
        }

        #fileInput {
            display: none;
        }

        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        button.secondary {
            background-color: #2196F3;
        }

        button.warning {
            background-color: #ff9800;
        }

        button.danger {
            background-color: #f44336;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }

        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .result-section {
            margin-top: 30px;
        }

        .result-table {
            overflow-x: auto;
            max-height: 500px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .instructions {
            background-color: #e7f3fe;
            border-left: 6px solid #2196F3;
            padding: 10px 15px;
            margin-bottom: 20px;
        }

        .error {
            color: #f44336;
            font-weight: bold;
        }

        .success {
            color: #4CAF50;
            font-weight: bold;
        }

        .warning {
            font-weight: bold;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 900px;
            border-radius: 8px;
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        .data-filter {
            margin: 15px 0;
            padding: 15px;
            background-color: #fff8e1;
            border-radius: 4px;
        }

        .filter-options {
            margin: 10px 0;
        }

        .filter-option {
            margin-right: 15px;
            display: inline-block;
        }

        .outlier {
            background-color: #ffebee;
        }

        .zero-value {
            background-color: #fff3e0;
        }

        .negative-value {
            background-color: #e3f2fd;
        }

        .selected-to-remove {
            background-color: #ffcdd2 !important;
        }

        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
            border-radius: 4px 4px 0 0;
        }

        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 10px 16px;
            transition: 0.3s;
            color: #333;
            margin-right: 0;
            border-radius: 0;
        }

        .tab button:hover {
            background-color: #ddd;
        }

        .tab button.active {
            background-color: #4CAF50;
            color: white;
        }

        .tabcontent {
            display: none;
            padding: 15px;
            border: 1px solid #ccc;
            border-top: none;
            border-radius: 0 0 4px 4px;
            background-color: white;
        }

        .stats-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
        }

        .stat-card {
            flex: 1;
            min-width: 200px;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .stat-card h4 {
            margin-top: 0;
            color: #555;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>å¢å¼ºç‰ˆCPKè®¡ç®—å™¨ - å¸¦æ•°æ®æ¸…ç†åŠŸèƒ½</h1>

        <div class="instructions">
            <p><strong>ä½¿ç”¨è¯´æ˜ï¼š</strong></p>
            <ol>
                <li>å‡†å¤‡Excelæ–‡ä»¶ï¼Œè¡¨å¤´æ ¼å¼ä¸ºï¼š<code>æè¿°(å‚è€ƒå€¼Â±å…¬å·®)</code>ï¼Œä¾‹å¦‚ï¼š<code>TIA_Y(100Â±20)</code></li>
                <li>ç‚¹å‡»"é€‰æ‹©æ–‡ä»¶"æˆ–æ‹–æ”¾Excelæ–‡ä»¶åˆ°ä¸Šä¼ åŒºåŸŸ</li>
                <li>æ£€æŸ¥å¹¶æ¸…ç†å¼‚å¸¸æ•°æ®ï¼ˆæ”¯æŒä¸‰ç§æ¸…ç†æ–¹å¼ï¼‰</li>
                <li>è®¡ç®—CPKå€¼å¹¶å¯¼å‡ºåˆ†ææŠ¥å‘Š</li>
            </ol>
        </div>

        <div class="upload-area" id="dropArea" onclick="document.getElementById('fileInput').click()">
            <i>ğŸ“</i>
            <p>ç‚¹å‡»é€‰æ‹©Excelæ–‡ä»¶æˆ–æ‹–æ”¾æ–‡ä»¶åˆ°æ­¤å¤„</p>
            <input type="file" id="fileInput" accept=".xlsx,.xls" onchange="handleFileSelect(event)">
        </div>

        <div id="fileInfo"></div>

        <div id="dataProcessingSection" style="display: none;">
            <h2>æ•°æ®å¤„ç†</h2>

            <div class="data-filter">
                <h3>æ•°æ®æ¸…ç†é€‰é¡¹</h3>
                <div class="filter-options">
                    <div class="filter-option">
                        <button onclick="openOutlierModal()" class="secondary">å¯è§†åŒ–é€‰æ‹©å‰”é™¤</button>
                    </div>
                    <div class="filter-option">
                        <button onclick="autoRemoveOutliers()" class="warning">è‡ªåŠ¨å‰”é™¤å¼‚å¸¸å€¼</button>
                    </div>
                    <div class="filter-option">
                        <button onclick="removeAllOutsideLimits()" class="danger">å‰”é™¤å…¨éƒ¨éä¸Šä¸‹é™çš„å€¼</button>
                    </div>
                </div>
                <p><small>æç¤ºï¼šå¼‚å¸¸å€¼åŒ…æ‹¬0ã€è´Ÿå€¼ã€è¶…å‡ºÂ±3ÏƒèŒƒå›´çš„å€¼</small></p>
            </div>

            <div class="tab">
                <button class="tablinks active" onclick="openTab(event, 'originalData')">åŸå§‹æ•°æ®</button>
                <button class="tablinks" onclick="openTab(event, 'cleanedData')">æ¸…ç†åæ•°æ®</button>
                <button class="tablinks" onclick="openTab(event, 'statsView')">ç»Ÿè®¡è§†å›¾</button>
            </div>

            <div id="originalData" class="tabcontent" style="display: block;">
                <h3>åŸå§‹æ•°æ® (å«å¼‚å¸¸å€¼æ ‡è®°)</h3>
                <div class="result-table">
                    <table id="dataPreview">
                        <thead></thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <div id="cleanedData" class="tabcontent">
                <h3>æ¸…ç†åæ•°æ®</h3>
                <div class="result-table">
                    <table id="cleanedDataPreview">
                        <thead></thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <div id="statsView" class="tabcontent">
                <h3>æ•°æ®ç»Ÿè®¡</h3>
                <div class="stats-summary" id="statsSummary"></div>
                <div class="result-table">
                    <table id="statsTable">
                        <thead>
                            <tr>
                                <th>é¡¹ç›®</th>
                                <th>åŸå§‹æ•°æ®é‡</th>
                                <th>å¼‚å¸¸å€¼æ•°é‡</th>
                                <th>æ¸…ç†åæ•°æ®é‡</th>
                                <th>å¼‚å¸¸å€¼æ¯”ä¾‹</th>
                                <th>æœ€å°å€¼</th>
                                <th>æœ€å¤§å€¼</th>
                                <th>å¹³å‡å€¼</th>
                                <th>æ ‡å‡†å·®</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <div>
                <button onclick="calculateCPK()" id="calculateBtn">è®¡ç®—CPK</button>
                <button onclick="exportResults()" id="exportBtn" disabled>å¯¼å‡ºç»“æœ</button>
                <button onclick="clearData()" id="clearBtn">æ¸…é™¤æ•°æ®</button>
            </div>
        </div>

        <div class="result-section" id="cpkResultSection" style="display: none;">
            <h2>CPKåˆ†æç»“æœ</h2>
            <div class="result-table">
                <table id="cpkResults">
                    <thead>
                        <tr>
                            <th>é¡¹ç›®</th>
                            <th>å‚è€ƒå€¼</th>
                            <th>ä¸Šé™</th>
                            <th>ä¸‹é™</th>
                            <th>æ•°æ®é‡</th>
                            <th>å¹³å‡å€¼</th>
                            <th>æ ‡å‡†å·®</th>
                            <th>CP</th>
                            <th>CPK</th>
                            <th>è¿‡ç¨‹èƒ½åŠ›è¯„ä¼°</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- å¼‚å¸¸å€¼é€‰æ‹©æ¨¡æ€æ¡† -->
    <div id="outlierModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>é€‰æ‹©è¦å‰”é™¤çš„å¼‚å¸¸å€¼</h2>
            <div id="modalFilterOptions">
                <label><input type="checkbox" id="filterNegatives" checked> åŒ…å«è´Ÿå€¼</label>
                <label><input type="checkbox" id="filterZeros" checked> åŒ…å«0å€¼</label>
                <label><input type="checkbox" id="filterOutliers" checked> åŒ…å«è¶…å‡ºÂ±3Ïƒçš„å€¼</label>
                <button onclick="filterOutliers()" class="secondary">åº”ç”¨ç­›é€‰</button>
            </div>
            <div class="form-group">
                <label>å•ä½ï¼š</label>
                <select id="unitSelect" onchange="updateUnit()">
                    <option value="um" selected>Î¼m (å¾®ç±³)</option>
                    <option value="mm">mm (æ¯«ç±³)</option>
                </select>
            </div>
            <div class="form-group">
                <label>å¼‚å¸¸å€¼å®šä¹‰ï¼š</label>
                <select id="outlierDefinition" onchange="toggleOutlierOptions()">
                    <option value="sigma">Â±Ïƒå€æ•°</option>
                    <option value="absolute">ç»å¯¹å€¼èŒƒå›´</option>
                </select>
                <div id="sigmaOptions">
                    Â±<input type="number" id="sigmaValue" min="1" max="10" step="0.5" value="3">Ïƒ
                </div>
                <div id="absoluteOptions" style="display:none;">
                    <input type="number" id="absMin" placeholder="æœ€å°å€¼">
                    ~
                    <input type="number" id="absMax" placeholder="æœ€å¤§å€¼">
                </div>
            </div>
            <div class="result-table" style="max-height: 400px;">
                <table id="outlierTable">
                    <thead>
                        <tr>
                            <th>é€‰æ‹©</th>
                            <th>è¡Œå·</th>
                            <th>é¡¹ç›®</th>
                            <th>å€¼</th>
                            <th>å‚è€ƒå€¼</th>
                            <th>ä¸Šé™</th>
                            <th>ä¸‹é™</th>
                            <th>ç±»å‹</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div style="margin-top: 15px;">
                <button onclick="confirmRemoveSelected()" class="secondary">å‰”é™¤é€‰ä¸­é¡¹</button>
                <button onclick="closeModal()">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <script>
        let rawData = [];
        let cleanedData = [];
        let specs = {};
        let cpkResults = [];
        let stats = {};
        let outliers = [];
        let currentUnit = 'um'; // é»˜è®¤å•ä½

        // è®¾ç½®æ‹–æ”¾åŠŸèƒ½
        const dropArea = document.getElementById('dropArea');

        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.style.borderColor = '#4CAF50';
            dropArea.style.backgroundColor = '#f0fff0';
        });

        dropArea.addEventListener('dragleave', () => {
            dropArea.style.borderColor = '#ccc';
            dropArea.style.backgroundColor = '';
        });

        dropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dropArea.style.borderColor = '#ccc';
            dropArea.style.backgroundColor = '';

            if (e.dataTransfer.files.length) {
                handleFileSelect({ target: { files: e.dataTransfer.files } });
            }
        });

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('fileInfo').innerHTML = `<p class="success">å·²é€‰æ‹©æ–‡ä»¶: ${file.name}</p>`;

            const reader = new FileReader();
            reader.onload = function (e) {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });

                // è·å–ç¬¬ä¸€ä¸ªå·¥ä½œè¡¨
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];

                // è½¬æ¢ä¸ºJSON
                rawData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                cleanedData = JSON.parse(JSON.stringify(rawData));

                // è§£æè§„æ ¼
                parseSpecs(rawData[0]);

                // åˆ†ææ•°æ®
                analyzeData();

                // æ˜¾ç¤ºæ•°æ®å¤„ç†åŒºåŸŸ
                document.getElementById('dataProcessingSection').style.display = 'block';

                // é¢„è§ˆæ•°æ®
                previewData();
            };
            reader.readAsArrayBuffer(file);
        }

        // è§£æè¡¨å¤´è§„æ ¼
        function parseSpecs(headers) {
            specs = {};
            // æ”¯æŒè´Ÿå€¼çš„æ­£åˆ™è¡¨è¾¾å¼
            const specPattern = /^(.+?)\((-?\d+\.?\d*)\s*Â±\s*(\d+\.?\d*)\)$/;

            headers.forEach((header, index) => {
                if (typeof header !== 'string') return;

                const match = header.match(specPattern);
                if (match) {
                    const target = parseFloat(match[2]);  // å¯èƒ½ä¸ºè´Ÿå€¼
                    const tolerance = parseFloat(match[3]);
                    specs[index] = {
                        name: match[1],
                        target: target,
                        tolerance: tolerance,
                        usl: target + tolerance,  // ä¸Šé™
                        lsl: target - tolerance   // ä¸‹é™
                    };
                    console.log(`è§£æåˆ— ${match[1]}: ç›®æ ‡å€¼=${target}, å…¬å·®=${tolerance}, èŒƒå›´=[${target - tolerance}, ${target + tolerance}]`);
                }
            });
        }

        // åˆ†ææ•°æ®å¹¶è¯†åˆ«å¼‚å¸¸å€¼
        function analyzeData() {
            stats = {};
            outliers = [];

            // å¯¹æ¯ä¸ªæœ‰è§„æ ¼çš„åˆ—è¿›è¡Œåˆ†æ
            Object.keys(specs).forEach(col => {
                col = parseInt(col);
                const spec = specs[col];
                const values = [];

                // é¦–å…ˆæ”¶é›†æ‰€æœ‰æœ‰æ•ˆæ•°æ®å¹¶è®¡ç®—åŸºæœ¬ç»Ÿè®¡é‡
                for (let i = 1; i < rawData.length; i++) {
                    const val = parseFloat(rawData[i][col]);
                    if (!isNaN(val)) {
                        values.push(val);
                    }
                }

                if (values.length === 0) {
                    stats[col] = {
                        name: spec.name,
                        originalCount: 0,
                        cleanedCount: 0,
                        outlierCount: 0,
                        min: NaN,
                        max: NaN,
                        avg: NaN,
                        std: NaN,
                        usl: spec.usl,
                        lsl: spec.lsl
                    };
                    return;
                }

                // è®¡ç®—ç»Ÿè®¡é‡
                const sum = values.reduce((a, b) => a + b, 0);
                const avg = sum / values.length;
                const squaredDiffs = values.map(x => Math.pow(x - avg, 2));
                const variance = squaredDiffs.reduce((a, b) => a + b, 0) / values.length;
                const std = Math.sqrt(variance);
                const min = Math.min(...values);
                const max = Math.max(...values);

                // ä¿å­˜ç»Ÿè®¡ä¿¡æ¯
                stats[col] = {
                    name: spec.name,
                    originalCount: values.length,
                    cleanedCount: values.length,
                    outlierCount: 0,
                    min: min,
                    max: max,
                    avg: avg,
                    std: std,
                    usl: spec.usl,
                    lsl: spec.lsl
                };

                // ç°åœ¨å¯ä»¥å®‰å…¨åœ°è°ƒç”¨ getOutlierRange
                const range = getOutlierRange(col);

                // è¯†åˆ«å¼‚å¸¸å€¼
                const columnOutliers = [];
                for (let i = 1; i < rawData.length; i++) {
                    const val = parseFloat(rawData[i][col]);
                    if (isNaN(val)) continue;

                    let type = '';
                    if (val === 0) {
                        type = 'é›¶å€¼';
                    } else if (val < range.lower || val > range.upper) {
                        type = 'ç¦»ç¾¤å€¼';
                    } else if (val < spec.lsl || val > spec.usl) {
                        type = 'è¶…é™å€¼';
                    }

                    if (type) {
                        columnOutliers.push({
                            row: i,
                            col: col,
                            value: val,
                            type: type
                        });
                    }
                }

                outliers.push(...columnOutliers);
                stats[col].outlierCount = columnOutliers.length;
                stats[col].cleanedCount = values.length - columnOutliers.length;
            });

            updateStatsView();
        }

        function getOutlierRange(col) {
            const method = document.getElementById('outlierDefinition').value;
            const stat = stats[col];

            // ç¡®ä¿ç»Ÿè®¡ä¿¡æ¯å·²è®¡ç®—
            if (!stat || isNaN(stat.avg) || isNaN(stat.std)) {
                return {
                    lower: -Infinity,
                    upper: Infinity
                };
            }

            if (method === 'sigma') {
                const sigmaMultiplier = parseFloat(document.getElementById('sigmaValue').value) || 3;
                return {
                    lower: stat.avg - sigmaMultiplier * stat.std,
                    upper: stat.avg + sigmaMultiplier * stat.std
                };
            } else {
                const absMin = parseFloat(document.getElementById('absMin').value) || -Infinity;
                const absMax = parseFloat(document.getElementById('absMax').value) || Infinity;
                return {
                    lower: absMin,
                    upper: absMax
                };
            }
        }

        // é¢„è§ˆæ•°æ®
        function previewData() {
            const previewTable = document.getElementById('dataPreview');
            const thead = previewTable.querySelector('thead');
            const tbody = previewTable.querySelector('tbody');

            // æ¸…ç©ºè¡¨æ ¼
            thead.innerHTML = '';
            tbody.innerHTML = '';

            if (rawData.length === 0) return;

            // æ·»åŠ è¡¨å¤´
            const headerRow = document.createElement('tr');
            rawData[0].forEach((header, index) => {
                const th = document.createElement('th');
                th.textContent = header;
                if (specs[index]) {
                    th.style.backgroundColor = '#e8f5e9';
                }
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            // æ·»åŠ æ•°æ®è¡Œï¼ˆæœ€å¤šæ˜¾ç¤º50è¡Œï¼‰
            const displayRows = Math.min(50, rawData.length - 1);
            for (let i = 1; i <= displayRows; i++) {
                const row = document.createElement('tr');
                rawData[i].forEach((cell, j) => {
                    const td = document.createElement('td');
                    const val = parseFloat(cell);

                    if (!isNaN(val)) {
                        // æ£€æŸ¥æ˜¯å¦æ˜¯å¼‚å¸¸å€¼
                        const isOutlier = outliers.some(o => o.row === i && o.col === j);
                        if (isOutlier) {
                            const outlier = outliers.find(o => o.row === i && o.col === j);
                            if (outlier.type === 'é›¶å€¼') {
                                td.classList.add('zero-value');
                            } else if (outlier.type === 'è´Ÿå€¼') {
                                td.classList.add('negative-value');
                            } else {
                                td.classList.add('outlier');
                            }
                        }
                    }

                    td.textContent = cell;
                    row.appendChild(td);
                });
                tbody.appendChild(row);
            }

            if (rawData.length > 50) {
                const infoRow = document.createElement('tr');
                const infoCell = document.createElement('td');
                infoCell.colSpan = rawData[0].length;
                infoCell.textContent = `...ä»…æ˜¾ç¤ºå‰50è¡Œï¼Œå…±${rawData.length - 1}è¡Œæ•°æ®...`;
                infoCell.style.textAlign = 'center';
                infoCell.style.fontStyle = 'italic';
                infoRow.appendChild(infoCell);
                tbody.appendChild(infoRow);
            }

            // æ›´æ–°æ¸…ç†åæ•°æ®é¢„è§ˆ
            updateCleanedDataPreview();
        }

        // æ›´æ–°æ¸…ç†åæ•°æ®é¢„è§ˆ
        function updateCleanedDataPreview() {
            const previewTable = document.getElementById('cleanedDataPreview');
            const thead = previewTable.querySelector('thead');
            const tbody = previewTable.querySelector('tbody');

            // æ¸…ç©ºè¡¨æ ¼
            thead.innerHTML = '';
            tbody.innerHTML = '';

            if (cleanedData.length === 0) return;

            // æ·»åŠ è¡¨å¤´
            const headerRow = document.createElement('tr');
            cleanedData[0].forEach((header, index) => {
                const th = document.createElement('th');
                th.textContent = header;
                if (specs[index]) {
                    th.style.backgroundColor = '#e8f5e9';
                }
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            // æ·»åŠ æ•°æ®è¡Œï¼ˆæœ€å¤šæ˜¾ç¤º50è¡Œï¼‰
            const displayRows = Math.min(50, cleanedData.length - 1);
            for (let i = 1; i <= displayRows; i++) {
                const row = document.createElement('tr');
                cleanedData[i].forEach((cell, j) => {
                    const td = document.createElement('td');
                    td.textContent = cell;
                    row.appendChild(td);
                });
                tbody.appendChild(row);
            }

            if (cleanedData.length > 50) {
                const infoRow = document.createElement('tr');
                const infoCell = document.createElement('td');
                infoCell.colSpan = cleanedData[0].length;
                infoCell.textContent = `...ä»…æ˜¾ç¤ºå‰50è¡Œï¼Œå…±${cleanedData.length - 1}è¡Œæ•°æ®...`;
                infoCell.style.textAlign = 'center';
                infoCell.style.fontStyle = 'italic';
                infoRow.appendChild(infoCell);
                tbody.appendChild(infoRow);
            }
        }

        // æ›´æ–°ç»Ÿè®¡è§†å›¾
        function updateStatsView() {
            const statsTable = document.getElementById('statsTable').querySelector('tbody');
            const statsSummary = document.getElementById('statsSummary');

            // æ¸…ç©ºè¡¨æ ¼
            statsTable.innerHTML = '';
            statsSummary.innerHTML = '';

            // æ·»åŠ ç»Ÿè®¡å¡ç‰‡
            let totalOutliers = 0;
            let totalOriginal = 0;

            Object.keys(stats).forEach(col => {
                totalOriginal += stats[col].originalCount;
                totalOutliers += stats[col].outlierCount;
            });

            const outlierPercentage = totalOriginal > 0 ? (totalOutliers / totalOriginal * 100).toFixed(1) : 0;

            statsSummary.innerHTML = `
                <div class="stat-card">
                    <h4>æ€»æ•°æ®ç‚¹</h4>
                    <div class="stat-value">${totalOriginal}</div>
                    <p>åŸå§‹æ•°æ®é‡</p>
                </div>
                <div class="stat-card">
                    <h4>å¼‚å¸¸å€¼</h4>
                    <div class="stat-value">${totalOutliers}</div>
                    <p>å æ€»æ•°æ® ${outlierPercentage}%</p>
                </div>
                <div class="stat-card">
                    <h4>æœ‰æ•ˆæ•°æ®</h4>
                    <div class="stat-value">${totalOriginal - totalOutliers}</div>
                    <p>æ¸…ç†åæ•°æ®é‡</p>
                </div>
            `;

            // æ·»åŠ è¯¦ç»†ç»Ÿè®¡
            Object.keys(stats).forEach(col => {
                col = parseInt(col);
                const stat = stats[col];
                const row = document.createElement('tr');

                const addCell = (value, decimals = 2) => {
                    const td = document.createElement('td');
                    if (typeof value === 'number' && !isNaN(value)) {
                        td.textContent = value.toFixed(decimals);
                    } else {
                        td.textContent = value;
                    }
                    row.appendChild(td);
                };

                addCell(stat.name);
                addCell(stat.originalCount, 0);
                addCell(stat.outlierCount, 0);
                addCell(stat.cleanedCount, 0);
                addCell(stat.originalCount > 0 ? (stat.outlierCount / stat.originalCount * 100).toFixed(1) + '%' : '0%');
                addCell(stat.min);
                addCell(stat.max);
                addCell(stat.avg);
                addCell(stat.std);

                statsTable.appendChild(row);
            });
        }

        // æ‰“å¼€å¼‚å¸¸å€¼é€‰æ‹©æ¨¡æ€æ¡†
        function openOutlierModal() {
            const modal = document.getElementById('outlierModal');
            const tableBody = document.getElementById('outlierTable').querySelector('tbody');

            tableBody.innerHTML = '';

            // æ·»åŠ å¼‚å¸¸å€¼åˆ°è¡¨æ ¼
            outliers.forEach(outlier => {
                const row = document.createElement('tr');
                const spec = specs[outlier.col];

                // é«˜äº®æ˜¾ç¤ºä¸åŒç±»å‹çš„å¼‚å¸¸å€¼
                if (outlier.type === 'é›¶å€¼') {
                    row.classList.add('zero-value');
                } else if (outlier.type === 'è´Ÿå€¼') {
                    row.classList.add('negative-value');
                } else {
                    row.classList.add('outlier');
                }

                row.innerHTML = `
                    <td><input type="checkbox" checked></td>
                    <td>${outlier.row}</td>
                    <td>${spec.name}</td>
                    <td>${outlier.value}</td>
                    <td>${spec.target}</td>
                    <td>${spec.usl}</td>
                    <td>${spec.lsl}</td>
                    <td>${outlier.type}</td>
                `;

                tableBody.appendChild(row);
            });

            modal.style.display = 'block';
        }

        // å…³é—­æ¨¡æ€æ¡†
        function closeModal() {
            document.getElementById('outlierModal').style.display = 'none';
        }

        // ç­›é€‰å¼‚å¸¸å€¼
        function filterOutliers() {
            const showNegatives = document.getElementById('filterNegatives').checked;
            const showZeros = document.getElementById('filterZeros').checked;
            const showOutliers = document.getElementById('filterOutliers').checked;

            const rows = document.getElementById('outlierTable').querySelectorAll('tbody tr');

            rows.forEach(row => {
                const type = row.cells[7].textContent;
                let shouldShow = false;

                if (type === 'è´Ÿå€¼' && showNegatives) shouldShow = true;
                if (type === 'é›¶å€¼' && showZeros) shouldShow = true;
                if ((type === 'ç¦»ç¾¤å€¼' || type === 'è¶…é™å€¼') && showOutliers) shouldShow = true;

                row.style.display = shouldShow ? '' : 'none';
            });
        }

        // ç¡®è®¤å‰”é™¤é€‰ä¸­çš„å¼‚å¸¸å€¼
        function confirmRemoveSelected() {
            const rows = document.getElementById('outlierTable').querySelectorAll('tbody tr');
            const rowsToRemove = [];

            rows.forEach(row => {
                if (row.style.display !== 'none') {
                    const checkbox = row.querySelector('input[type="checkbox"]');
                    if (checkbox.checked) {
                        const rowNum = parseInt(row.cells[1].textContent);
                        const colNum = outliers.find(o => o.row === rowNum).col;
                        rowsToRemove.push({ row: rowNum, col: colNum });
                    }
                }
            });

            removeOutliers(rowsToRemove);
            closeModal();
        }

        // è‡ªåŠ¨å‰”é™¤å¼‚å¸¸å€¼
        function autoRemoveOutliers() {
            if (confirm('ç¡®å®šè¦è‡ªåŠ¨å‰”é™¤æ‰€æœ‰å¼‚å¸¸å€¼ï¼ˆè´Ÿå€¼ã€é›¶å€¼ã€è¶…å‡ºÂ±3Ïƒçš„å€¼ï¼‰å—ï¼Ÿ')) {
                removeOutliers(outliers);
            }
        }

        // å‰”é™¤å…¨éƒ¨éä¸Šä¸‹é™çš„å€¼
        function removeAllOutsideLimits() {
            if (confirm('ç¡®å®šè¦å‰”é™¤æ‰€æœ‰è¶…å‡ºè§„æ ¼ä¸Šä¸‹é™çš„å€¼å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚')) {
                const outliersToRemove = [];

                Object.keys(specs).forEach(col => {
                    col = parseInt(col);
                    const spec = specs[col];

                    for (let i = 1; i < cleanedData.length; i++) {
                        const val = parseFloat(cleanedData[i][col]);
                        if (isNaN(val)) continue;

                        if (val < spec.lsl || val > spec.usl) {
                            outliersToRemove.push({ row: i, col: col });
                        }
                    }
                });

                removeOutliers(outliersToRemove);
            }
        }

        // æ‰§è¡Œå‰”é™¤æ“ä½œ
        function removeOutliers(outliersToRemove) {
            // åˆ›å»ºè¡Œåˆ é™¤æ ‡è®°ï¼ˆå› ä¸ºä»æ•°ç»„ä¸­åˆ é™¤è¡Œä¼šå½±å“è¡Œå·ï¼‰
            const rowsToDelete = new Set();
            outliersToRemove.forEach(o => rowsToDelete.add(o.row));

            // ä»cleanedDataä¸­åˆ é™¤è¡Œï¼ˆä»åå¾€å‰åˆ é™¤ä»¥é¿å…ç´¢å¼•é—®é¢˜ï¼‰
            const rowsToDeleteSorted = Array.from(rowsToDelete).sort((a, b) => b - a);
            rowsToDeleteSorted.forEach(row => {
                cleanedData.splice(row, 1);
            });

            // é‡æ–°åˆ†ææ•°æ®
            analyzeData();

            // æ›´æ–°æ•°æ®é¢„è§ˆ
            previewData();

            // æ˜¾ç¤ºæ¶ˆæ¯
            alert(`å·²å‰”é™¤ ${outliersToRemove.length} ä¸ªå¼‚å¸¸å€¼ï¼Œå½±å“ ${rowsToDelete.size} è¡Œæ•°æ®ã€‚`);
        }

        // è®¡ç®—CPK
        function calculateCPK() {
            if (cleanedData.length < 2) {
                alert('æ²¡æœ‰å¯è®¡ç®—çš„æ•°æ®ï¼');
                return;
            }

            if (Object.keys(specs).length === 0) {
                alert('æœªæ£€æµ‹åˆ°ç¬¦åˆè§„æ ¼çš„åˆ—ï¼è¯·ç¡®ä¿è¡¨å¤´æ ¼å¼ä¸º"æè¿°(å‚è€ƒå€¼Â±å…¬å·®)"');
                return;
            }

            cpkResults = [];

            // å¯¹æ¯ä¸ªæœ‰è§„æ ¼çš„åˆ—è¿›è¡Œè®¡ç®—
            Object.keys(specs).forEach(col => {
                col = parseInt(col);
                const spec = specs[col];
                const values = [];

                // æ”¶é›†æ•°æ®ï¼ˆè·³è¿‡éæ•°å­—å€¼ï¼‰
                for (let i = 1; i < cleanedData.length; i++) {
                    const val = parseFloat(cleanedData[i][col]);
                    if (!isNaN(val)) {
                        values.push(val);
                    }
                }

                if (values.length === 0) {
                    cpkResults.push({
                        name: spec.name,
                        target: spec.target,
                        usl: spec.usl,
                        lsl: spec.lsl,
                        count: 0,
                        avg: NaN,
                        std: NaN,
                        cp: NaN,
                        cpk: NaN,
                        assessment: 'æ— æœ‰æ•ˆæ•°æ®'
                    });
                    return;
                }

                // è®¡ç®—ç»Ÿè®¡é‡
                const sum = values.reduce((a, b) => a + b, 0);
                const avg = sum / values.length;
                const squaredDiffs = values.map(x => Math.pow(x - avg, 2));
                const variance = squaredDiffs.reduce((a, b) => a + b, 0) / values.length;
                const std = Math.sqrt(variance);

                // è®¡ç®—CPå’ŒCPK
                const cp = (spec.usl - spec.lsl) / (6 * std);
                const cpu = (spec.usl - avg) / (3 * std);
                const cpl = (avg - spec.lsl) / (3 * std);
                const cpk = Math.min(cpu, cpl);

                // è¯„ä¼°è¿‡ç¨‹èƒ½åŠ›
                let assessment;
                if (cpk >= 1.67) {
                    assessment = 'ä¼˜ç§€';
                } else if (cpk >= 1.33) {
                    assessment = 'è‰¯å¥½';
                } else if (cpk >= 1.0) {
                    assessment = 'ä¸€èˆ¬';
                } else if (cpk >= 0.67) {
                    assessment = 'ä¸è¶³';
                } else {
                    assessment = 'ä¸¥é‡ä¸è¶³';
                }

                cpkResults.push({
                    name: spec.name,
                    target: spec.target,
                    usl: spec.usl,
                    lsl: spec.lsl,
                    count: values.length,
                    avg: avg,
                    std: std,
                    cp: cp,
                    cpk: cpk,
                    assessment: assessment
                });
            });

            displayCPKResults();
            document.getElementById('exportBtn').disabled = false;
            document.getElementById('cpkResultSection').style.display = 'block';
        }

        // æ˜¾ç¤ºCPKç»“æœ
        function displayCPKResults() {
            const resultsTable = document.getElementById('cpkResults').querySelector('tbody');
            resultsTable.innerHTML = '';

            cpkResults.forEach(result => {
                const row = document.createElement('tr');

                const addCell = (value, decimals = 2) => {
                    const td = document.createElement('td');
                    if (typeof value === 'number' && !isNaN(value)) {
                        td.textContent = value.toFixed(decimals);
                    } else {
                        td.textContent = value;
                    }
                    row.appendChild(td);
                };

                addCell(result.name);
                addCell(result.target);
                addCell(result.usl);
                addCell(result.lsl);
                addCell(result.count, 0);
                addCell(result.avg);
                addCell(result.std);
                addCell(result.cp);
                addCell(result.cpk);

                const assessmentCell = document.createElement('td');
                assessmentCell.textContent = result.assessment;

                // æ ¹æ®è¯„ä¼°ç»“æœè®¾ç½®é¢œè‰²
                switch (result.assessment) {
                    case 'ä¼˜ç§€':
                        assessmentCell.style.color = '#2E7D32';
                        assessmentCell.style.fontWeight = 'bold';
                        break;
                    case 'è‰¯å¥½':
                        assessmentCell.style.color = '#689F38';
                        break;
                    case 'ä¸€èˆ¬':
                        assessmentCell.style.color = '#FBC02D';
                        break;
                    case 'ä¸è¶³':
                        assessmentCell.style.color = '#EF6C00';
                        break;
                    case 'ä¸¥é‡ä¸è¶³':
                        assessmentCell.style.color = '#C62828';
                        assessmentCell.style.fontWeight = 'bold';
                        break;
                }

                row.appendChild(assessmentCell);
                resultsTable.appendChild(row);
            });
        }

        // å¯¼å‡ºç»“æœ
        function exportResults() {
            if (cpkResults.length === 0) {
                alert('æ²¡æœ‰ç»“æœå¯å¯¼å‡ºï¼');
                return;
            }

            try {
                // åˆ›å»ºå·¥ä½œç°¿
                const wb = XLSX.utils.book_new();
                
                // 1. æ·»åŠ CPKç»“æœè¡¨
                const cpkData = [
                    ['é¡¹ç›®', 'å‚è€ƒå€¼', 'ä¸Šé™', 'ä¸‹é™', 'æ•°æ®é‡', 'å¹³å‡å€¼', 'æ ‡å‡†å·®', 'CP', 'CPK', 'è¿‡ç¨‹èƒ½åŠ›è¯„ä¼°'],
                    ...cpkResults.map(result => [
                        result.name,
                        result.target,
                        result.usl,
                        result.lsl,
                        result.count,
                        result.avg,
                        result.std,
                        result.cp,
                        result.cpk,
                        result.assessment
                    ])
                ];
                const cpkWs = XLSX.utils.aoa_to_sheet(cpkData);
                XLSX.utils.book_append_sheet(wb, cpkWs, "CPKåˆ†æç»“æœ");

                // 2. æ·»åŠ æ¸…ç†åçš„æ•°æ®è¡¨
                const dataWs = XLSX.utils.aoa_to_sheet(cleanedData);
                XLSX.utils.book_append_sheet(wb, dataWs, "æµ‹é‡æ•°æ®");

                // å¯¼å‡ºExcelæ–‡ä»¶
                XLSX.writeFile(wb, "CPKåˆ†ææŠ¥å‘Š.xlsx");
                
            } catch (error) {
                console.error('å¯¼å‡ºå¤±è´¥:', error);
                alert('å¯¼å‡ºå¤±è´¥: ' + error.message);
            }
        }

        // æ¸…é™¤æ•°æ®
        function clearData() {
            rawData = [];
            cleanedData = [];
            specs = {};
            cpkResults = [];
            stats = {};
            outliers = [];

            document.getElementById('dataPreview').querySelector('thead').innerHTML = '';
            document.getElementById('dataPreview').querySelector('tbody').innerHTML = '';
            document.getElementById('cleanedDataPreview').querySelector('thead').innerHTML = '';
            document.getElementById('cleanedDataPreview').querySelector('tbody').innerHTML = '';
            document.getElementById('cpkResults').querySelector('tbody').innerHTML = '';
            document.getElementById('statsTable').querySelector('tbody').innerHTML = '';
            document.getElementById('statsSummary').innerHTML = '';
            document.getElementById('fileInfo').innerHTML = '';

            document.getElementById('dataProcessingSection').style.display = 'none';
            document.getElementById('cpkResultSection').style.display = 'none';
            document.getElementById('exportBtn').disabled = true;
        }

        // æ ‡ç­¾é¡µåˆ‡æ¢
        function openTab(evt, tabName) {
            const tabcontent = document.getElementsByClassName("tabcontent");
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }

            const tablinks = document.getElementsByClassName("tablinks");
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }

            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }

        function toggleOutlierOptions() {
            const method = document.getElementById('outlierDefinition').value;
            document.getElementById('sigmaOptions').style.display = method === 'sigma' ? 'block' : 'none';
            document.getElementById('absoluteOptions').style.display = method === 'absolute' ? 'block' : 'none';
        }

        function updateUnit() {
            currentUnit = document.getElementById('unitSelect').value;
            // é‡æ–°æ˜¾ç¤ºæ•°æ®ï¼ˆå•ä½è½¬æ¢ï¼‰
            if (rawData.length > 0) {
                previewData();
                updateCleanedDataPreview();
            }
        }
    </script>
</body>

</html>