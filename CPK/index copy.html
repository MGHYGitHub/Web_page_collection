<!--
********************************************************************************
*  ğŸ“Š CPK è®¡ç®—å·¥å…·
*  ä½œè€…: ELI_MORGAN
*  ç‰ˆæœ¬: 2.2.6-Beta
*  å‘å¸ƒæ—¥æœŸ: 2025-09-12
*  å®˜æ–¹ç½‘ç«™/æ¥æº: https://github.com/MGHYGitHub/Web_page_collection
*  é˜²ä¼ªæ ‡è¯†: CPK-20250912-MGHY
*  è¯´æ˜: æœ¬å·¥å…·ç”¨äº Excel/CSV æ•°æ®çš„ CPK åˆ†æä¸å¯è§†åŒ–ï¼Œ
*        ç¦æ­¢æœªç»æˆæƒçš„å¤åˆ¶æˆ–åˆ†å‘ã€‚
********************************************************************************
-->
<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>CPK è®¡ç®—å·¥å…·</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- æ›¿æ¢è¿™äº›CDNå¼•ç”¨ -->
    <!-- <script src="./js/xlsx.full.min.js"></script>
    <script src="./js/chart.js"></script>
    <script src="./js/chartjs-plugin-datalabels.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./css/font-awesome.min.css"> -->
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 20px;
            background: #f7f9fc;
        }

        #footerInfo {
            font-size: 12px;
            color: #888;
            text-align: center;
            margin-top: 20px;
        }

        h2 {
            text-align: center;
            margin-bottom: 20px;
        }

        .upload-box {
            text-align: center;
            margin-bottom: 15px;
        }

        input[type="file"] {
            padding: 8px 12px;
            border: 2px solid #4e73df;
            border-radius: 8px;
            cursor: pointer;
            background: #fff;
            transition: 0.3s;
        }

        input[type="file"]:hover {
            background: #4e73df;
            color: #fff;
        }

        .card {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            padding: 20px;
            margin-bottom: 30px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        th,
        td {
            border: 1px solid #e3e6f0;
            padding: 10px;
            text-align: center;
        }

        th {
            background: #4e73df;
            color: #fff;
        }

        tr:nth-child(even) {
            background: #f8f9fc;
        }

        canvas {
            max-width: 100%;
            height: 400px;
        }

        .button-container {
            text-align: center;
            margin: 20px 0;
        }

        .button-container button {
            padding: 10px 20px;
            margin: 0 5px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
        }

        #generateChartsBtn {
            background: #4CAF50;
            color: white;
        }

        #toggleParamChartBtn {
            background: #2196F3;
            color: white;
        }

        #toggleValidBtn {
            background: #FF9800;
            color: white;
        }

        .filter-buttons {
            text-align: center;
            margin: 10px 0;
        }

        .filter-buttons button {
            margin: 5px;
            padding: 8px 15px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            background: #6c757d;
            color: #fff;
        }

        .filter-buttons button.active {
            background: #4e73df;
            font-weight: bold;
        }

        .button-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .button-container button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background: #4e73df;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }

        .button-container button:hover {
            background: #2e59d9;
        }

        #exportReportBtn {
            background: #9c27b0;
        }

        #exportReportBtn:hover {
            background: #7b1fa2;
        }

        /* æ ¼å¼é€‰æ‹©å™¨æ ·å¼ */
        select#reportFormat {
            background: white;
            border: 1px solid #ddd;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
        }

        select#reportFormat:focus {
            outline: none;
            border-color: #4e73df;
            box-shadow: 0 0 0 2px rgba(78, 115, 223, 0.25);
        }

        /* æ¯›ç»ç’ƒæ»šåŠ¨å…¬å‘Šæ¡æ ·å¼ */
        .announcement-bar {
            position: relative;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px 0;
            margin-bottom: 20px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .announcement-content {
            display: flex;
            white-space: nowrap;
            animation: scrollAnnouncement 30s linear infinite;
            padding: 0 20px;
        }

        .announcement-item {
            display: inline-flex;
            align-items: center;
            margin-right: 40px;
            font-size: 14px;
            font-weight: 500;
            color: #4e73df;
        }

        .announcement-item i {
            margin-right: 8px;
            font-size: 16px;
        }

        @keyframes scrollAnnouncement {
            0% {
                transform: translateX(100%);
            }

            100% {
                transform: translateX(-100%);
            }
        }

        .announcement-bar:hover .announcement-content {
            animation-play-state: paused;
        }
    </style>
</head>

<body>
    <!-- æ¯›ç»ç’ƒæ»šåŠ¨å…¬å‘Šæ¡ -->
    <!-- æ¯›ç»ç’ƒæ»šåŠ¨å…¬å‘Šæ¡ -->
    <div class="announcement-bar">
        <div class="announcement-content">
            <div class="announcement-item"><i>ğŸ“¢</i> æ¬¢è¿ä½¿ç”¨ CPK è®¡ç®—å·¥å…· v2.2.6-Beta</div>
            <div class="announcement-item"><i>â­</i> æ–°å¢æ•°æ®ç­›é€‰å’Œå¯¼å‡ºåŠŸèƒ½</div>
            <div class="announcement-item"><i>ğŸ””</i> æ”¯æŒ Excel/CSV æ ¼å¼æ•°æ®å¯¼å…¥</div>
            <div class="announcement-item"><i>ğŸŒ</i> è¯·ä½¿ç”¨è°·æ­Œæµè§ˆå™¨(Chrome)è·å¾—æœ€ä½³ä½“éªŒ</div>
            <div class="announcement-item"><i>ğŸ“ˆ</i> ç”Ÿæˆä¸“ä¸šç»Ÿè®¡å›¾è¡¨å’ŒæŠ¥å‘Š</div>
            <div class="announcement-item"><i>âš ï¸</i> æ³¨æ„ï¼šè¯·å‹¿ä¸Šä¼ æ•æ„Ÿæ•°æ®</div>
        </div>
    </div>
    <h2>ğŸ“Š CPK è®¡ç®—å·¥å…·</h2>
    <div class="upload-box">
        <input type="file" id="excelFile" accept=".xlsx,.xls,.csv" />
    </div>

    <div id="result" class="card"></div>

    <!-- åœ¨æŒ‰é’®å®¹å™¨ä¸­æ·»åŠ  -->
    <div class="button-container">
        <button id="generateChartsBtn">ğŸ“Š ç”Ÿæˆç»Ÿè®¡å›¾</button>
        <button id="toggleParamChartBtn">ğŸ”„ å‚æ•°æ³¢åŠ¨å›¾</button>
        <button id="toggleValidBtn">åˆ‡æ¢æœ‰æ•ˆ/æºæ•°æ®æ˜¾ç¤º</button>
        <!-- ä¿®æ”¹ä¸ºä¸‹æ‹‰é€‰æ‹© -->
        <select id="dataLabelsMode" style="padding:8px 12px; border-radius:6px; border:1px solid #ccc;">
            <option value="smart">ğŸ”¢ æ™ºèƒ½æ˜¾ç¤ºæ ‡ç­¾</option>
            <option value="none">âŒ éšè—æ•°æ®æ ‡ç­¾</option>
            <option value="hover">ğŸ–±ï¸ æ‚¬åœæ˜¾ç¤ºæ ‡ç­¾</option>
            <option value="important">â­ ä»…å…³é”®æ•°æ®</option>
        </select>
        <span id="validModeLabel" style="margin-left:10px; font-weight:bold; color:#1cc88a;">
            å½“å‰æ¨¡å¼ï¼šæœ‰æ•ˆæ•°æ®
        </span>
    </div>

    <!-- ç­›é€‰æŒ‰é’® -->
    <div class="filter-buttons" style="text-align:center; margin: 15px 0;">
        <button id="showAllBtn" class="active">å…¨éƒ¨æ•°æ®</button>
        <button id="showValidBtn">æœ‰æ•ˆæ•°æ®</button>
        <button id="showInvalidBtn">æ— æ•ˆæ•°æ®</button>
        <button id="showInSpecBtn">ä»…ä¸è¶…æ ‡</button>
        <div id="modeIndicator" style="margin: 10px 0; font-weight: bold; color: #1976d2;">
            ğŸ“Š å½“å‰æ¨¡å¼ï¼šå…¨éƒ¨æ•°æ®
        </div>
    </div>

    <!-- å¯¼å‡ºæŒ‰é’® -->
    <div class="button-container">
        <button id="exportDataChartBtn">å¯¼å‡ºæ•°æ®è¶‹åŠ¿å›¾ (PNG)</button>
        <button id="exportCpkChartBtn">å¯¼å‡º CP/CPK å›¾ (PNG)</button>
        <button id="exportFailChartBtn">å¯¼å‡ºè¶…æ ‡ç‡å›¾ (PNG)</button>
        <!-- æ–°å¢å¯¼å‡ºæŠ¥å‘ŠæŒ‰é’® -->
        <button id="exportReportBtn" style="background: #9c27b0; color: white;">ğŸ“‹ å¯¼å‡ºå®Œæ•´æŠ¥å‘Š</button>
    </div>

    <!-- æ·»åŠ æŠ¥å‘Šæ ¼å¼é€‰æ‹© -->
    <div style="text-align: center; margin: 10px 0;">
        <label for="reportFormat" style="font-weight: bold;">æŠ¥å‘Šæ ¼å¼ï¼š</label>
        <select id="reportFormat" style="padding: 6px 12px; border-radius: 6px; border: 1px solid #ccc;">
            <option value="excel">Excel æ ¼å¼</option>
        </select>
    </div>


    <!-- å›¾è¡¨å®¹å™¨ -->
    <div id="chartsContainer" style="display:none;">
        <div class="card">
            <h3 style="text-align:center; color:#444;">æ•°æ®è¶‹åŠ¿è§†å›¾ï¼ˆå‡å€¼ã€ä¸Šä¸‹é™ã€æå€¼ï¼‰</h3>
            <canvas id="dataChart"></canvas>
        </div>
        <div class="card">
            <h3 style="text-align:center; color:#444;">CP / CPK è¶‹åŠ¿å›¾</h3>
            <canvas id="cpkChart"></canvas>
        </div>
        <div class="card">
            <h3 style="text-align:center; color:#444;">è¶…æ ‡ç‡ (%)</h3>
            <canvas id="failChart"></canvas>
        </div>
    </div>

    <!-- å‚æ•°æ³¢åŠ¨å›¾ -->
    <div id="paramChartContainer" class="card" style="display:none;">
        <label for="paramSelect" style="font-weight:bold;">é€‰æ‹©å‚æ•°ï¼š</label>
        <select id="paramSelect" style="padding:6px 10px;border-radius:6px;border:1px solid #ccc;"></select>
        <div style="margin-top:20px;">
            <canvas id="paramTrendChart"></canvas>
        </div>
    </div>

    <div id="footerInfo">
        ä½œè€…: ELI_MORGAN | ç‰ˆæœ¬: 2.2.6-Beta | é˜²ä¼ªæ ‡è¯†: CPK-20250912-MGHY
    </div>

    <script>
        let dataChartInstance = null, cpkChartInstance = null, failChartInstance = null, paramTrendChart = null;
        let rawData = [], columns = [];
        let useValidData = true;
        let validData = [], invalidData = [], inSpecData = [];
        let filterMode = "all"; // all / valid / invalid / inSpec
        let currentMode = "å…¨éƒ¨æ•°æ®"; // å½“å‰ç­›é€‰æ¨¡å¼
        let showDataLabels = true; // é»˜è®¤æ˜¾ç¤ºæ•°æ®æ ‡ç­¾
        let dataLabelsMode = "smart"; // smart, none, hover, important
        let reportData = [];

        // æ–‡ä»¶å¯¼å…¥
        document.getElementById("excelFile").addEventListener("change", handleFile, false);
        function handleFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (event) {
                try {
                    const data = new Uint8Array(event.target.result);
                    const workbook = XLSX.read(data, { type: "array" });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                    if (!jsonData || jsonData.length < 2) {
                        alert("æ–‡ä»¶æ•°æ®ä¸è¶³æˆ–æ ¼å¼ä¸æ­£ç¡®ï¼");
                        return;
                    }

                    rawData = jsonData.slice(1).map(r => {
                        let obj = {};
                        jsonData[0].forEach((h, i) => { obj[h] = r[i]; });
                        return obj;
                    });
                    columns = jsonData[0];
                    processData([columns, ...rawData.map(r => columns.map(h => r[h]))]);
                } catch (error) {
                    console.error("æ–‡ä»¶å¤„ç†é”™è¯¯:", error);
                    alert("æ–‡ä»¶å¤„ç†å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼ï¼");
                }
            };
            reader.readAsArrayBuffer(file);
        }

        /// ä¿®æ”¹ processData å‡½æ•°ä¸­çš„å¼‚å¸¸å€¼æ£€æµ‹é€»è¾‘
        function processData(data) {
            const headers = data[0], rows = data.slice(1);
            let result = `<table><tr>
                <th>å‚æ•°</th><th>è§„æ ¼</th><th>ä¸Šé™</th><th>ä¸‹é™</th>
                <th>æœ€å¤§å€¼</th><th>æœ€å°å€¼</th><th>å¹³å‡å€¼</th><th>æ ‡å‡†å·®</th>
                <th>CP</th><th>CPK</th><th>è¶…æ ‡æ•°</th><th>è¶…æ ‡ç‡</th>
                <th>æœ‰æ•ˆæ•°</th><th>æ— æ•ˆæ•°</th></tr>`;

            let chartLabels = [], cpData = [], cpkData = [], failRateData = [];
            let meanData = [], uslData = [], lslData = [], maxData = [], minData = [], outOfSpecData = [];

            reportData = [];
            for (let col = 2; col < headers.length; col++) {
                const specText = headers[col];
                const match = specText.match(/([-]?\d+\.?\d*)\s*Â±\s*(\d+\.?\d*)/);
                if (!match) continue;

                const target = parseFloat(match[1]), tol = parseFloat(match[2]);
                const USL = target + tol, LSL = target - tol;

                // ç°åœ¨ col åœ¨ for å¾ªç¯ä¸­å®šä¹‰ï¼Œå¯ä»¥æ­£ç¡®ä½¿ç”¨
                const valuesAll = rows.map(r => parseFloat(r[col]));
                const values = valuesAll.filter(v => !isNaN(v));

                // ä¿®å¤çš„å¼‚å¸¸å€¼å‰”é™¤é€»è¾‘ - å¤„ç†æ ‡å‡†å€¼ä¸º0çš„æƒ…å†µ
                let valuesValid, invalidValues;

                if (target === 0) {
                    // å½“æ ‡å‡†å€¼ä¸º0æ—¶ï¼Œä½¿ç”¨ç»å¯¹å®¹å·®
                    const maxTolerance = tol * 3;
                    valuesValid = values.filter(v => Math.abs(v) <= maxTolerance);
                    invalidValues = values.filter(v => Math.abs(v) > maxTolerance);
                } else {
                    // å½“æ ‡å‡†å€¼ä¸ä¸º0æ—¶ï¼Œä½¿ç”¨ç›¸å¯¹å®¹å·® (15%)
                    const relativeTolerance = 0.15; // 15%çš„ç›¸å¯¹å®¹å·®
                    const maxRelativeDeviation = Math.abs(target) * relativeTolerance;
                    valuesValid = values.filter(v => Math.abs(v - target) <= maxRelativeDeviation);
                    invalidValues = values.filter(v => Math.abs(v - target) > maxRelativeDeviation);
                }

                // æ ¹æ® useValidData å†³å®šæ˜¯å¦ä½¿ç”¨æœ‰æ•ˆæ•°æ®
                let baseData = useValidData ? valuesValid : values;

                let dataToUse = [];
                if (filterMode === "all") {
                    dataToUse = baseData;
                } else if (filterMode === "valid") {
                    dataToUse = valuesValid;
                } else if (filterMode === "invalid") {
                    dataToUse = invalidValues;
                } else if (filterMode === "inSpec") {
                    dataToUse = baseData.filter(v => v >= LSL && v <= USL);
                }

                if (dataToUse.length === 0) continue;

                const maxVal = Math.max(...dataToUse);
                const minVal = Math.min(...dataToUse);
                const mean = dataToUse.reduce((a, b) => a + b, 0) / dataToUse.length;
                const std = Math.sqrt(dataToUse.reduce((a, b) => a + (b - mean) ** 2, 0) / (dataToUse.length - 1));

                // å¤„ç†æ ‡å‡†å·®ä¸º0çš„æƒ…å†µ
                let CP, CPK;
                if (std === 0) {
                    CP = Infinity;
                    CPK = Infinity;
                } else {
                    CP = (USL - LSL) / (6 * std);
                    const Cpk1 = (USL - mean) / (3 * std);
                    const Cpk2 = (mean - LSL) / (3 * std);
                    CPK = Math.min(Cpk1, Cpk2);
                }

                const outOfSpec = dataToUse.filter(v => v > USL || v < LSL).length;
                const outRate = (outOfSpec / dataToUse.length) * 100;

                // æ·»åŠ CP/CPKé¢œè‰²åˆ¤æ–­å‡½æ•°
                function getCpkColor(cpkValue) {
                    if (cpkValue === Infinity) return '#1b5e20'; // æ— ç©·å¤§è§†ä¸ºè‰¯å¥½
                    if (cpkValue > 1.67) return '#1b5e20'; // æ·±ç»¿è‰² - è‰¯å¥½
                    if (cpkValue > 1.33) return '#2e7d32'; // ç»¿è‰² - åˆæ ¼
                    return '#c62828'; // çº¢è‰² - ä¸åˆæ ¼
                }

                function getCpColor(cpValue) {
                    if (cpValue === Infinity) return '#1b5e20'; // æ— ç©·å¤§è§†ä¸ºè‰¯å¥½
                    if (cpValue > 1.67) return '#1b5e20'; // æ·±ç»¿è‰² - è‰¯å¥½
                    if (cpValue > 1.33) return '#2e7d32'; // ç»¿è‰² - åˆæ ¼
                    return '#c62828'; // çº¢è‰² - ä¸åˆæ ¼
                }

                // åœ¨å¾ªç¯å†…æ·»åŠ è¡¨æ ¼è¡Œ
                result += `<tr>
                            <td>${specText}</td><td>${target}Â±${tol}</td>
                            <td>${USL.toFixed(2)}</td><td>${LSL.toFixed(2)}</td>
                            <td>${maxVal.toFixed(2)}</td><td>${minVal.toFixed(2)}</td>
                            <td>${mean.toFixed(2)}</td><td>${std.toFixed(2)}</td>
                            <td style="background-color: ${getCpColor(CP)}; color: white; font-weight: bold;">${CP === Infinity ? "âˆ" : CP.toFixed(3)}</td>
                            <td style="background-color: ${getCpkColor(CPK)}; color: white; font-weight: bold;">${CPK === Infinity ? "âˆ" : CPK.toFixed(3)}</td>
                            <td>${outOfSpec}</td><td>${outRate.toFixed(2)}%</td>
                            <td style="background-color: #e8f5e9; color: #2e7d32; font-weight: bold;">${valuesValid.length}</td>
                            <td style="background-color: #ffebee; color: #c62828; font-weight: bold;">${invalidValues.length}</td>
                        </tr>`;

                // ä¿å­˜å›¾è¡¨æ•°æ®
                chartLabels.push(specText);
                cpData.push(CP === Infinity ? 10 : CP.toFixed(3)); // å°†æ— ç©·å¤§æ˜ å°„ä¸º10ä»¥ä¾¿æ˜¾ç¤º
                cpkData.push(CPK === Infinity ? 10 : CPK.toFixed(3));
                failRateData.push(outRate.toFixed(2));
                meanData.push(mean.toFixed(2));
                uslData.push(USL.toFixed(2));
                lslData.push(LSL.toFixed(2));
                maxData.push(maxVal);
                minData.push(minVal);
                outOfSpecData.push(outOfSpec);

                // ä¿å­˜åˆ°æŠ¥å‘Šæ•°æ®
                reportData.push({
                    parameter: specText,
                    target: `${target}Â±${tol}`,
                    usl: USL.toFixed(2),
                    lsl: LSL.toFixed(2),
                    max: maxVal.toFixed(2),
                    min: minVal.toFixed(2),
                    mean: mean.toFixed(2),
                    std: std.toFixed(2),
                    cp: CP === Infinity ? "âˆ" : CP.toFixed(3),
                    cpk: CPK === Infinity ? "âˆ" : CPK.toFixed(3),
                    outOfSpec: outOfSpec,
                    outRate: outRate.toFixed(2) + '%',
                    validCount: valuesValid.length,
                    invalidCount: invalidValues.length,
                    cpColor: getCpColor(CP),
                    cpkColor: getCpkColor(CPK)
                });
            }

            result += "</table>";
            document.getElementById("result").innerHTML = result;
            document.getElementById("dataLabelsMode").value = "smart";

            // ä¿å­˜å›¾è¡¨æ•°æ®
            window.chartData = { labels: chartLabels, cpData, cpkData, failRateData, meanData, uslData, lslData, maxData, minData, outOfSpecData };
        }

        // æ›´æ–°æŒ‰é’®æ¿€æ´»çŠ¶æ€
        function updateButtonActiveState() {
            document.querySelectorAll('.filter-buttons button').forEach(btn => {
                btn.classList.remove('active');
            });

            if (filterMode === "all") document.getElementById("showAllBtn").classList.add('active');
            else if (filterMode === "valid") document.getElementById("showValidBtn").classList.add('active');
            else if (filterMode === "invalid") document.getElementById("showInvalidBtn").classList.add('active');
            else if (filterMode === "inSpec") document.getElementById("showInSpecBtn").classList.add('active');
        }

        // æŒ‰é’®ç»‘å®š
        document.getElementById("showAllBtn").addEventListener("click", () => {
            filterMode = "all";
            updateModeIndicator("å…¨éƒ¨æ•°æ®");
            updateButtonActiveState();
            reprocessData();
        });
        document.getElementById("showValidBtn").addEventListener("click", () => {
            filterMode = "valid";
            updateModeIndicator("æœ‰æ•ˆæ•°æ®");
            updateButtonActiveState();
            reprocessData();
        });
        document.getElementById("showInvalidBtn").addEventListener("click", () => {
            filterMode = "invalid";
            updateModeIndicator("æ— æ•ˆæ•°æ®");
            updateButtonActiveState();
            reprocessData();
        });
        document.getElementById("showInSpecBtn").addEventListener("click", () => {
            filterMode = "inSpec";
            updateModeIndicator("ä»…ä¸è¶…æ ‡æ•°æ®");
            updateButtonActiveState();
            reprocessData();
        });

        // é‡æ–°å¤„ç†æ•°æ®
        function reprocessData() {
            if (columns.length > 0 && rawData.length > 0) {
                processData([columns, ...rawData.map(r => columns.map(h => r[h]))]);
                if (document.getElementById("chartsContainer").style.display === "block") {
                    renderDataChart(window.chartData.labels, window.chartData.meanData, window.chartData.uslData, window.chartData.lslData, window.chartData.maxData, window.chartData.minData);
                    renderCpkChart(window.chartData.labels, window.chartData.cpData, window.chartData.cpkData);
                    renderFailChart(window.chartData.labels, window.chartData.failRateData, window.chartData.outOfSpecData);
                }
            }
        }

        // æ›´æ–°æ¨¡å¼æç¤º
        function updateModeIndicator(text) {
            document.getElementById("modeIndicator").textContent = "ğŸ“Š å½“å‰æ¨¡å¼ï¼š" + text;
        }

        // ç”Ÿæˆå›¾è¡¨æŒ‰é’®
        document.getElementById("generateChartsBtn").addEventListener("click", function () {
            if (!window.chartData || !window.chartData.labels) {
                alert("è¯·å…ˆä¸Šä¼ æ•°æ®æ–‡ä»¶ï¼");
                return;
            }

            document.getElementById("chartsContainer").style.display = "block";
            const chartData = window.chartData;
            renderDataChart(chartData.labels, chartData.meanData, chartData.uslData, chartData.lslData, chartData.maxData, chartData.minData);
            renderCpkChart(chartData.labels, chartData.cpData, chartData.cpkData);
            renderFailChart(chartData.labels, chartData.failRateData, chartData.outOfSpecData);
        });
        // æ·»åŠ å¯¼å‡ºæŠ¥å‘ŠæŒ‰é’®çš„äº‹ä»¶ç›‘å¬å™¨
        document.getElementById("exportReportBtn").addEventListener("click", function () {
            if (reportData.length === 0) {
                alert("è¯·å…ˆä¸Šä¼ æ•°æ®æ–‡ä»¶å¹¶ç”Ÿæˆåˆ†æç»“æœï¼");
                return;
            }
            exportExcelReport();
        });
        // æœ‰æ•ˆ/æºæ•°æ®åˆ‡æ¢
        document.getElementById("toggleValidBtn").addEventListener("click", function () {
            useValidData = !useValidData;
            const label = document.getElementById("validModeLabel");
            if (useValidData) {
                this.textContent = "åˆ‡æ¢æœ‰æ•ˆ/æºæ•°æ®æ˜¾ç¤º";
                label.textContent = "å½“å‰æ¨¡å¼ï¼šæœ‰æ•ˆæ•°æ®";
                label.style.color = "#1cc88a";
            } else {
                this.textContent = "åˆ‡æ¢æº/æœ‰æ•ˆæ•°æ®æ˜¾ç¤º";
                label.textContent = "å½“å‰æ¨¡å¼ï¼šåŒ…å«æ— æ•ˆæ•°æ®";
                label.style.color = "#e74a3b";
            }
            reprocessData(); // é‡æ–°å¤„ç†æ•°æ®
        });

        // ä¸‹è½½å‡½æ•°
        // ä¸‹è½½å‡½æ•°
        function downloadChart(chartInstance, fileName) {
            if (!chartInstance || !chartInstance.canvas) return alert("å›¾è¡¨æœªç”Ÿæˆï¼");
            const link = document.createElement('a');
            link.href = chartInstance.toBase64Image();
            link.download = fileName;
            link.click();
        }

        // åªç»‘å®šä¸€æ¬¡äº‹ä»¶ç›‘å¬å™¨
        document.getElementById("exportDataChartBtn").addEventListener("click", () => {
            if (!dataChartInstance) {
                alert("è¯·å…ˆç”Ÿæˆæ•°æ®è¶‹åŠ¿å›¾ï¼");
                return;
            }
            downloadChart(dataChartInstance, "æ•°æ®è¶‹åŠ¿å›¾.png");
        });

        document.getElementById("exportCpkChartBtn").addEventListener("click", () => {
            if (!cpkChartInstance) {
                alert("è¯·å…ˆç”ŸæˆCP/CPKå›¾ï¼");
                return;
            }
            downloadChart(cpkChartInstance, "CP_CPKå›¾.png");
        });

        document.getElementById("exportFailChartBtn").addEventListener("click", () => {
            if (!failChartInstance) {
                alert("è¯·å…ˆç”Ÿæˆè¶…æ ‡ç‡å›¾ï¼");
                return;
            }
            downloadChart(failChartInstance, "è¶…æ ‡ç‡å›¾.png");
        });

        // æ™ºèƒ½æ•°æ®æ ‡ç­¾å‡½æ•°
        function addSmartDataLabels(chart, meanData, maxData, minData) {
            if (!chart || !chart.ctx) return;

            const ctx = chart.ctx;
            const datasets = chart.data.datasets;

            // ç¡®ä¿animationå¯¹è±¡å­˜åœ¨
            chart.options.animation = chart.options.animation || {};

            chart.options.animation.onComplete = function () {
                if (dataLabelsMode === "none" || !ctx) return;

                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = 'bold 12px Arial';

                // åªæ˜¾ç¤ºå…³é”®æ•°æ®ç‚¹çš„æ ‡ç­¾ï¼ˆå¹³å‡å€¼ã€æœ€å¤§å€¼ã€æœ€å°å€¼ï¼‰
                const importantIndices = new Set();

                // æ‰¾å‡ºæ¯ä¸ªå‚æ•°çš„å…³é”®ç‚¹ç´¢å¼•
                meanData.forEach((_, index) => {
                    importantIndices.add(index);
                });

                importantIndices.forEach(index => {
                    // å¹³å‡å€¼æ ‡ç­¾
                    const meanMeta = chart.getDatasetMeta(0);
                    if (meanMeta && meanMeta.data[index]) {
                        const meanPos = meanMeta.data[index].tooltipPosition();
                        drawDataLabel(ctx, meanData[index], meanPos.x, meanPos.y - 20, "#4e73df");
                    }

                    // æœ€å¤§å€¼æ ‡ç­¾
                    const maxMeta = chart.getDatasetMeta(3);
                    if (maxMeta && maxMeta.data[index]) {
                        const maxPos = maxMeta.data[index].tooltipPosition();
                        drawDataLabel(ctx, maxData[index], maxPos.x, maxPos.y - 25, "#1cc88a");
                    }

                    // æœ€å°å€¼æ ‡ç­¾
                    const minMeta = chart.getDatasetMeta(4);
                    if (minMeta && minMeta.data[index]) {
                        const minPos = minMeta.data[index].tooltipPosition();
                        drawDataLabel(ctx, minData[index], minPos.x, minPos.y + 25, "#f6c23e");
                    }
                });

                ctx.restore();
            };

            chart.update();
        }

        // ç»˜åˆ¶å•ä¸ªæ•°æ®æ ‡ç­¾
        function drawDataLabel(ctx, value, x, y, color) {
            const text = typeof value === 'number' ? value.toFixed(2) : value;
            const textWidth = ctx.measureText(text).width + 12;
            const textHeight = 20;

            // ç»˜åˆ¶èƒŒæ™¯æ¡†
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(x - textWidth / 2, y - textHeight / 2, textWidth, textHeight, 6);
            ctx.fill();
            ctx.stroke();

            // ç»˜åˆ¶æ–‡å­—
            ctx.fillStyle = '#2c3e50';
            ctx.fillText(text, x, y + 2);

            // ç»˜åˆ¶æŒ‡ç¤ºçº¿
            ctx.beginPath();
            ctx.moveTo(x, y - textHeight / 2);
            ctx.lineTo(x, y - textHeight / 2 - 5);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        // CPK å›¾
        function renderCpkChart(labels, cpData, cpkData) {
            const ctx = document.getElementById("cpkChart").getContext("2d");
            if (cpkChartInstance) cpkChartInstance.destroy();

            cpkChartInstance = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "CP",
                            data: cpData,
                            borderColor: "#1cc88a",
                            fill: false,
                            tension: 0.2,
                            pointBackgroundColor: "#1cc88a",
                            pointRadius: 5
                        },
                        {
                            label: "CPK",
                            data: cpkData,
                            borderColor: "#4e73df",
                            fill: false,
                            tension: 0.2,
                            pointBackgroundColor: "#4e73df",
                            pointRadius: 5
                        },
                        {
                            label: "è­¦æˆ’çº¿ (1.33)",
                            data: new Array(labels.length).fill(1.33),
                            borderColor: "#e74a3b",
                            borderDash: [6, 6],
                            fill: false,
                            pointRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    interaction: { mode: "index", intersect: false }
                }
            });
        }

        // è¶…æ ‡ç‡å›¾
        function renderFailChart(labels, failRateData, outOfSpecData) {
            const ctx = document.getElementById("failChart").getContext("2d");
            if (failChartInstance) failChartInstance.destroy();

            failChartInstance = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "è¶…æ ‡ç‡ (%)",
                            data: failRateData,
                            backgroundColor: "rgba(231, 74, 59, 0.7)",
                            yAxisID: "y1"
                        },
                        {
                            label: "è¶…æ ‡æ•°",
                            data: outOfSpecData,
                            type: "line",
                            borderColor: "#4e73df",
                            borderWidth: 2,
                            fill: false,
                            yAxisID: "y2",
                            pointRadius: 4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    interaction: { mode: "index", intersect: false },
                    scales: {
                        y1: { type: "linear", position: "left", title: { display: true, text: "è¶…æ ‡ç‡ (%)" } },
                        y2: { type: "linear", position: "right", title: { display: true, text: "è¶…æ ‡æ•°" }, grid: { drawOnChartArea: false } }
                    }
                }
            });
        }

        // åˆå§‹åŒ–æ•°æ®æ ‡ç­¾æ¨¡å¼
        document.getElementById("dataLabelsMode").value = "smart";

        // å‚æ•°æ³¢åŠ¨å›¾
        function renderParamTrendChart(paramIndex) {
            const ctx = document.getElementById("paramTrendChart").getContext("2d");
            if (paramTrendChart) paramTrendChart.destroy();

            const paramName = columns[paramIndex];
            const values = rawData.map(r => parseFloat(r[paramName])).filter(v => !isNaN(v));

            paramTrendChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: values.map((_, i) => i + 1),
                    datasets: [{
                        label: paramName,
                        data: values,
                        borderColor: "#36b9cc",
                        backgroundColor: "rgba(54, 185, 204, 0.1)",
                        fill: true,
                        tension: 0.2,
                        pointBackgroundColor: "#36b9cc",
                        pointBorderColor: "#36b9cc",
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: "æ ·æœ¬åºå·"
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: "æ•°å€¼"
                            }
                        }
                    }
                }
            });
        }
        // åˆå§‹åŒ–æ—¶è®¾ç½®æŒ‰é’®æ ·å¼
        document.getElementById("dataLabelsMode").value = "smart";

        // ç»‘å®šå‚æ•°æ³¢åŠ¨å›¾æŒ‰é’®
        document.getElementById("toggleParamChartBtn").addEventListener("click", function () {
            const container = document.getElementById("paramChartContainer");
            if (container.style.display === "none") {
                container.style.display = "block";
                const paramSelect = document.getElementById("paramSelect");
                paramSelect.innerHTML = "";

                // åªæ·»åŠ åŒ…å«è§„æ ¼ä¿¡æ¯çš„å‚æ•°
                if (columns && columns.length > 0) {
                    columns.forEach((c, i) => {
                        if (i >= 2 && c && c.match && c.match(/[-]?\d+\s*Â±\s*\d+/)) {
                            const opt = document.createElement("option");
                            opt.value = i;
                            opt.textContent = c;
                            paramSelect.appendChild(opt);
                        }
                    });

                    if (paramSelect.options.length > 0) {
                        renderParamTrendChart(parseInt(paramSelect.value));
                    }
                }
            } else {
                container.style.display = "none";
            }
        });

        document.getElementById("paramSelect").addEventListener("change", function () {
            renderParamTrendChart(parseInt(this.value));
        });

        // æ§åˆ¶å°è¾“å‡ºé˜²ä¼ªæ ‡è¯†
        console.log("%cğŸ“Š CPK è®¡ç®—å·¥å…·", "color:#4e73df; font-size:16px; font-weight:bold;");
        console.log("ä½œè€…: ELI_MORGAN");
        console.log("ç‰ˆæœ¬: 2.2.6-Beta");
        console.log("é˜²ä¼ªæ ‡è¯†: CPK-20250912-MGHY");
        console.log("æ¥æº: https://github.com/MGHYGitHub/Web_page_collection");

        // ä¿®æ”¹å›¾è¡¨æ¸²æŸ“å‡½æ•°ï¼Œæ·»åŠ æ•°æ®æ ‡ç­¾é…ç½®
        // ä¿®å¤å›¾è¡¨æ¸²æŸ“å‡½æ•°ï¼Œç¡®ä¿æ­£ç¡®çš„æ•°æ®é›†æ ‡ç­¾
        // æ•°æ®è¶‹åŠ¿å›¾ - å®Œæ•´ç‰ˆæœ¬
        function renderDataChart(labels, meanData, uslData, lslData, maxData, minData) {
            const ctx = document.getElementById("dataChart").getContext("2d");
            if (dataChartInstance) dataChartInstance.destroy();

            dataChartInstance = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "å¹³å‡å€¼",
                            data: meanData,
                            borderColor: "#4e73df",
                            backgroundColor: "rgba(78, 115, 223, 0.1)",
                            fill: true,
                            tension: 0.4,
                            pointBackgroundColor: "#4e73df",
                            pointBorderColor: "#ffffff",
                            pointBorderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8
                        },
                        {
                            label: "ä¸Šé™ (USL)",
                            data: uslData,
                            borderColor: "#e74a3b",
                            borderDash: [6, 6],
                            fill: false,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: "ä¸‹é™ (LSL)",
                            data: lslData,
                            borderColor: "#e74a3b",
                            borderDash: [6, 6],
                            fill: false,
                            pointRadius: 0,
                            borderWidth: 2
                        },
                        {
                            label: "æœ€å¤§å€¼",
                            data: maxData,
                            borderColor: "#1cc88a",
                            backgroundColor: "rgba(28, 200, 138, 0.2)",
                            type: "scatter",
                            pointStyle: "triangle",
                            pointRadius: 8,
                            showLine: false,
                            pointHoverRadius: 10
                        },
                        {
                            label: "æœ€å°å€¼",
                            data: minData,
                            borderColor: "#f6c23e",
                            backgroundColor: "rgba(246, 194, 62, 0.2)",
                            type: "scatter",
                            pointStyle: "rect",
                            pointRadius: 8,
                            showLine: false,
                            pointHoverRadius: 10
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 30,
                            bottom: 30,
                            left: 20,
                            right: 20
                        }
                    },
                    interaction: {
                        mode: "index",
                        intersect: false
                    },
                    plugins: {
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#4e73df',
                            borderWidth: 1,
                            cornerRadius: 6,
                            displayColors: true,
                            usePointStyle: true,
                            callbacks: {
                                label: function (context) {
                                    return `${context.dataset.label}: ${context.parsed.y}`;
                                }
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'æµ‹é‡æ•°å€¼',
                                font: {
                                    weight: 'bold',
                                    size: 14
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'å‚æ•°åç§°',
                                font: {
                                    weight: 'bold',
                                    size: 14
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 0
                            }
                        }
                    },
                    animation: {
                        duration: 1000,
                        easing: 'easeOutQuart'
                    },
                    elements: {
                        line: {
                            tension: 0.4
                        }
                    }
                }
            });
        }

        // CPK å›¾ - å®Œæ•´ç‰ˆæœ¬
        function renderCpkChart(labels, cpData, cpkData) {
            const ctx = document.getElementById("cpkChart").getContext("2d");
            if (cpkChartInstance) cpkChartInstance.destroy();

            // è®¡ç®—Yè½´çš„æœ€å¤§å€¼
            const maxCpValue = Math.max(...cpData.map(v => parseFloat(v) || 0), ...cpkData.map(v => parseFloat(v) || 0));
            const yMax = Math.max(2, maxCpValue) + 0.5;

            cpkChartInstance = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "CP",
                            data: cpData,
                            borderColor: "#1cc88a",
                            fill: false,
                            tension: 0.2,
                            pointBackgroundColor: "#1cc88a",
                            pointBorderColor: "#ffffff",
                            pointBorderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8
                        },
                        {
                            label: "CPK",
                            data: cpkData,
                            borderColor: "#4e73df",
                            fill: false,
                            tension: 0.2,
                            pointBackgroundColor: "#4e73df",
                            pointBorderColor: "#ffffff",
                            pointBorderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8
                        },
                        {
                            label: "è­¦æˆ’çº¿ (1.33)",
                            data: new Array(labels.length).fill(1.33),
                            borderColor: "#e74a3b",
                            borderDash: [6, 6],
                            fill: false,
                            pointRadius: 0,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 30,
                            bottom: 30,
                            left: 20,
                            right: 20
                        }
                    },
                    interaction: {
                        mode: "index",
                        intersect: false
                    },
                    plugins: {
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#4e73df',
                            borderWidth: 1,
                            cornerRadius: 6,
                            displayColors: true,
                            usePointStyle: true,
                            callbacks: {
                                label: function (context) {
                                    return `${context.dataset.label}: ${context.parsed.y}`;
                                }
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'CP/CPK å€¼',
                                font: {
                                    weight: 'bold',
                                    size: 14
                                }
                            },
                            min: 0,
                            max: yMax,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'å‚æ•°åç§°',
                                font: {
                                    weight: 'bold',
                                    size: 14
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 0
                            }
                        }
                    },
                    animation: {
                        duration: 1000,
                        easing: 'easeOutQuart'
                    }
                }
            });
        }

        // è¶…æ ‡ç‡å›¾ - å®Œæ•´ç‰ˆæœ¬
        function renderFailChart(labels, failRateData, outOfSpecData) {
            const ctx = document.getElementById("failChart").getContext("2d");
            if (failChartInstance) failChartInstance.destroy();

            failChartInstance = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "è¶…æ ‡ç‡ (%)",
                            data: failRateData,
                            backgroundColor: "rgba(231, 74, 59, 0.7)",
                            borderColor: "#e74a3b",
                            borderWidth: 1,
                            yAxisID: "y1",
                            barPercentage: 0.6,
                            categoryPercentage: 0.8
                        },
                        {
                            label: "è¶…æ ‡æ•°",
                            data: outOfSpecData,
                            type: "line",
                            borderColor: "#4e73df",
                            borderWidth: 3,
                            fill: false,
                            pointBackgroundColor: "#4e73df",
                            pointBorderColor: "#ffffff",
                            pointBorderWidth: 2,
                            pointRadius: 5,
                            pointHoverRadius: 7,
                            yAxisID: "y2"
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 40,
                            bottom: 30,
                            left: 20,
                            right: 20
                        }
                    },
                    interaction: {
                        mode: "index",
                        intersect: false
                    },
                    plugins: {
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#4e73df',
                            borderWidth: 1,
                            cornerRadius: 6,
                            displayColors: true,
                            usePointStyle: true,
                            callbacks: {
                                label: function (context) {
                                    return `${context.dataset.label}: ${context.parsed.y}`;
                                }
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            }
                        }
                    },
                    scales: {
                        y1: {
                            type: "linear",
                            position: "left",
                            title: {
                                display: true,
                                text: "è¶…æ ‡ç‡ (%)",
                                font: {
                                    weight: 'bold',
                                    size: 14
                                }
                            },
                            min: 0,
                            max: 100,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        y2: {
                            type: "linear",
                            position: "right",
                            title: {
                                display: true,
                                text: "è¶…æ ‡æ•°",
                                font: {
                                    weight: 'bold',
                                    size: 14
                                }
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            min: 0
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'å‚æ•°åç§°',
                                font: {
                                    weight: 'bold',
                                    size: 14
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 0
                            }
                        }
                    },
                    animation: {
                        duration: 1000,
                        easing: 'easeOutQuart'
                    }
                }
            });
        }
        // ä¿®å¤æ•°æ®æ ‡ç­¾æ’ä»¶ - ç¡®ä¿æ­£ç¡®æ˜¾ç¤ºå…³é”®æ•°æ®
        const smartDataLabelsPlugin = {
            id: 'smartDataLabels',
            afterDatasetsDraw(chart) {
                if (dataLabelsMode === "none") return;

                const ctx = chart.ctx;
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = 'bold 11px Arial';

                // ç¡®å®šè¦æ˜¾ç¤ºæ ‡ç­¾çš„æ•°æ®é›†
                let datasetsToLabel = [];

                if (dataLabelsMode === "important") {
                    // æ ¹æ®å›¾è¡¨ç±»å‹æ˜¾ç¤ºä¸åŒçš„å…³é”®æ•°æ®
                    if (chart.canvas.id === "dataChart") {
                        datasetsToLabel = chart.data.datasets.filter(d => d.label === "å¹³å‡å€¼");
                    } else if (chart.canvas.id === "cpkChart") {
                        datasetsToLabel = chart.data.datasets.filter(d => ["CP", "CPK"].includes(d.label));
                    } else if (chart.canvas.id === "failChart") {
                        datasetsToLabel = chart.data.datasets.filter(d => d.label === "è¶…æ ‡ç‡ (%)");
                    }
                } else if (dataLabelsMode === "smart") {
                    // æ™ºèƒ½æ¨¡å¼ï¼šæ˜¾ç¤ºå¹³å‡å€¼ã€æœ€å¤§å€¼ã€æœ€å°å€¼ï¼ˆä»…å¯¹æ•°æ®è¶‹åŠ¿å›¾ï¼‰
                    if (chart.canvas.id === "dataChart") {
                        datasetsToLabel = chart.data.datasets.filter(d =>
                            ["å¹³å‡å€¼", "æœ€å¤§å€¼", "æœ€å°å€¼"].includes(d.label)
                        );
                    }
                }

                const displayedPositions = [];
                const chartArea = chart.chartArea;

                datasetsToLabel.forEach((dataset, datasetIndex) => {
                    const meta = chart.getDatasetMeta(datasetIndex);
                    if (meta.hidden) return;

                    meta.data.forEach((element, index) => {
                        const value = dataset.data[index];
                        if (value === undefined || value === null) return;

                        const position = element.tooltipPosition();

                        // æ£€æŸ¥æ ‡ç­¾æ˜¯å¦åœ¨å›¾è¡¨åŒºåŸŸå†…
                        if (position.x < chartArea.left || position.x > chartArea.right ||
                            position.y < chartArea.top || position.y > chartArea.bottom) {
                            return;
                        }

                        // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–æ ‡ç­¾å¤ªè¿‘
                        const tooClose = displayedPositions.some(pos =>
                            Math.abs(pos.x - position.x) < 50 && Math.abs(pos.y - position.y) < 30
                        );

                        if (tooClose) return;

                        displayedPositions.push(position);

                        let yOffset = -20;
                        let bgColor = dataset.borderColor || '#000';

                        // æ ¹æ®ä¸åŒå›¾è¡¨ç±»å‹è°ƒæ•´ä½ç½®
                        if (chart.config.type === 'bar') {
                            yOffset = dataset.label === "è¶…æ ‡ç‡ (%)" ? -25 : 15;
                        } else if (dataset.type === 'scatter') {
                            yOffset = -25;
                        }

                        const y = position.y + yOffset;

                        // ç¡®ä¿æ ‡ç­¾åœ¨å›¾è¡¨åŒºåŸŸå†…
                        const finalY = Math.max(chartArea.top + 15, Math.min(chartArea.bottom - 15, y));
                        const text = typeof value === 'number' ? value.toFixed(2) : value;
                        const textWidth = ctx.measureText(text).width + 16;

                        // æ£€æŸ¥æ°´å¹³è¾¹ç•Œ
                        const x = Math.max(chartArea.left + textWidth / 2,
                            Math.min(chartArea.right - textWidth / 2, position.x));

                        // ç»˜åˆ¶èƒŒæ™¯æ¡†
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        ctx.strokeStyle = bgColor;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.roundRect(x - textWidth / 2, finalY - 10, textWidth, 20, 6);
                        ctx.fill();
                        ctx.stroke();

                        // ç»˜åˆ¶æ–‡å­—
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillText(text, x, finalY + 2);

                        // ä¸ºæ•£ç‚¹å›¾æ·»åŠ æŒ‡ç¤ºçº¿
                        if (dataset.type === 'scatter') {
                            ctx.beginPath();
                            ctx.moveTo(x, finalY - 10);
                            ctx.lineTo(position.x, position.y);
                            ctx.strokeStyle = bgColor;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    });
                });

                ctx.restore();
            }
        };
        // é‡æ–°æ³¨å†Œæ’ä»¶
        Chart.register(smartDataLabelsPlugin);

        // ä¿®å¤æ¨¡å¼åˆ‡æ¢åŠŸèƒ½
        document.getElementById("dataLabelsMode").addEventListener("change", function () {
            dataLabelsMode = this.value;
            updateAllCharts();
        });

        // ä¿®æ”¹æ›´æ–°å›¾è¡¨å‡½æ•°ï¼Œç¡®ä¿å®Œå…¨é‡æ–°æ¸²æŸ“
        function updateAllCharts() {
            if (dataChartInstance) {
                dataChartInstance.destroy();
                if (window.chartData) {
                    renderDataChart(window.chartData.labels, window.chartData.meanData,
                        window.chartData.uslData, window.chartData.lslData,
                        window.chartData.maxData, window.chartData.minData);
                }
            }
            if (cpkChartInstance) {
                cpkChartInstance.destroy();
                if (window.chartData) {
                    renderCpkChart(window.chartData.labels, window.chartData.cpData, window.chartData.cpkData);
                }
            }
            if (failChartInstance) {
                failChartInstance.destroy();
                if (window.chartData) {
                    renderFailChart(window.chartData.labels, window.chartData.failRateData, window.chartData.outOfSpecData);
                }
            }
            if (paramTrendChart) {
                paramTrendChart.destroy();
                const paramSelect = document.getElementById("paramSelect");
                if (paramSelect.value && columns.length > 0) {
                    renderParamTrendChart(parseInt(paramSelect.value));
                }
            }
        }

        // ç®€åŒ–æ•°æ®æ ‡ç­¾æ¨¡å¼ï¼Œç§»é™¤æ‚¬åœæ¨¡å¼ï¼ˆå¤ªéš¾å®ç°ï¼‰
        document.getElementById("dataLabelsMode").innerHTML = `
    <option value="smart">ğŸ”¢ æ™ºèƒ½æ˜¾ç¤ºæ ‡ç­¾</option>
    <option value="none">âŒ éšè—æ•°æ®æ ‡ç­¾</option>
    <option value="important">â­ ä»…å…³é”®æ•°æ®</option>
`;

        // æ·»åŠ ä¸€äº›CSSæ”¹å–„æ˜¾ç¤º
        const improvedStyle = document.createElement('style');
        improvedStyle.textContent = `
    .chartjs-tooltip {
        background: rgba(0, 0, 0, 0.8) !important;
        border-radius: 6px !important;
        padding: 8px 12px !important;
    }
    
    canvas {
        max-width: 100%;
        height: 450px !important; /* å¢åŠ é«˜åº¦ç»™æ ‡ç­¾æ›´å¤šç©ºé—´ */
    }
    
    .card {
        margin-bottom: 40px; /* å¢åŠ å¡ç‰‡é—´è· */
    }
`;
        document.head.appendChild(improvedStyle);
        // æ·»åŠ CSSç¡®ä¿å›¾è¡¨å®¹å™¨æœ‰è¶³å¤Ÿç©ºé—´
        const chartStyle = document.createElement('style');
        chartStyle.textContent = `
    .card canvas {
        height: 500px !important;
        max-height: 500px;
    }
    
    #chartsContainer {
        padding: 20px 0;
    }
    
    .chart-container {
        min-height: 550px;
        margin-bottom: 40px;
    }
`;

        // ExcelæŠ¥å‘Šå¯¼å‡ºå‡½æ•°
        function exportExcelReport() {
            try {
                // åˆ›å»ºå·¥ä½œç°¿
                const wb = XLSX.utils.book_new();

                // åˆ›å»ºæ•°æ®è¡¨
                const wsData = [
                    ['å‚æ•°åˆ†ææŠ¥å‘Š', '', '', '', '', '', '', '', '', '', '', '', '', ''],
                    ['ç”Ÿæˆæ—¶é—´: ' + new Date().toLocaleString(), '', '', '', '', '', '', '', '', '', '', '', '', ''],
                    [''],
                    ['å‚æ•°', 'è§„æ ¼', 'ä¸Šé™(USL)', 'ä¸‹é™(LSL)', 'æœ€å¤§å€¼', 'æœ€å°å€¼', 'å¹³å‡å€¼', 'æ ‡å‡†å·®', 'CP', 'CPK', 'è¶…æ ‡æ•°', 'è¶…æ ‡ç‡', 'æœ‰æ•ˆæ•°', 'æ— æ•ˆæ•°']
                ];

                // æ·»åŠ æ•°æ®è¡Œ
                reportData.forEach(item => {
                    wsData.push([
                        item.parameter,
                        item.target,
                        item.usl,
                        item.lsl,
                        item.max,
                        item.min,
                        item.mean,
                        item.std,
                        item.cp,
                        item.cpk,
                        item.outOfSpec,
                        item.outRate,
                        item.validCount,
                        item.invalidCount
                    ]);
                });

                // æ·»åŠ ç»Ÿè®¡ä¿¡æ¯
                wsData.push(['']);
                wsData.push(['ç»Ÿè®¡æ‘˜è¦', '', '', '', '', '', '', '', '', '', '', '', '', '']);

                const totalParams = reportData.length;
                const goodParams = reportData.filter(item => parseFloat(item.cpk) > 1.67).length;
                const okParams = reportData.filter(item => parseFloat(item.cpk) > 1.33 && parseFloat(item.cpk) <= 1.67).length;
                const badParams = reportData.filter(item => parseFloat(item.cpk) <= 1.33).length;

                wsData.push(['æ€»å‚æ•°æ•°é‡:', totalParams]);
                wsData.push(['è‰¯å¥½(CPK>1.67):', goodParams, `(${(goodParams / totalParams * 100).toFixed(1)}%)`]);
                wsData.push(['åˆæ ¼(1.33<CPKâ‰¤1.67):', okParams, `(${(okParams / totalParams * 100).toFixed(1)}%)`]);
                wsData.push(['ä¸åˆæ ¼(CPKâ‰¤1.33):', badParams, `(${(badParams / totalParams * 100).toFixed(1)}%)`]);

                const ws = XLSX.utils.aoa_to_sheet(wsData);

                // è®¾ç½®åˆ—å®½
                const colWidths = [
                    { wch: 25 }, { wch: 15 }, { wch: 12 }, { wch: 12 },
                    { wch: 10 }, { wch: 10 }, { wch: 10 }, { wch: 10 },
                    { wch: 8 }, { wch: 8 }, { wch: 10 }, { wch: 10 },
                    { wch: 10 }, { wch: 10 }
                ];
                ws['!cols'] = colWidths;

                // åˆå¹¶æ ‡é¢˜å•å…ƒæ ¼
                if (!ws['!merges']) ws['!merges'] = [];
                ws['!merges'].push({ s: { r: 0, c: 0 }, e: { r: 0, c: 13 } });
                ws['!merges'].push({ s: { r: 1, c: 0 }, e: { r: 1, c: 13 } });

                // æ·»åŠ å·¥ä½œè¡¨
                XLSX.utils.book_append_sheet(wb, ws, "CPKåˆ†ææŠ¥å‘Š");

                // ç”ŸæˆExcelæ–‡ä»¶å¹¶ä¸‹è½½
                const fileName = `CPKåˆ†ææŠ¥å‘Š_${new Date().toISOString().slice(0, 10)}.xlsx`;
                XLSX.writeFile(wb, fileName);

                alert(`ExcelæŠ¥å‘Šå·²ç”Ÿæˆ: ${fileName}`);
            } catch (error) {
                console.error("Excelå¯¼å‡ºé”™è¯¯:", error);
                alert("ExcelæŠ¥å‘Šå¯¼å‡ºå¤±è´¥ï¼Œè¯·é‡è¯•");
            }
        }


    </script>
</body>

</html>